---
description:
globs:
alwaysApply: true
---

---

description: React プロジェクトのコーディング規約・設計ガイドライン
globs: src/\*_/_

---

# 設計・構造ガイドライン

- プロジェクトのディレクトリ構成は`doc/directoryStructure.md`に準拠すること
- コンポーネントファイルは最大 300 行以内
- ロジックの責務を明確に分離する
- UI ロジックは UI と密結合、業務ロジックは UI と疎結合
- hooks の中にロジックを持たせない
- Feature 型ベースでディレクトリ管理
- 再利用可能コンポーネントは Feature 型の components/atoms 配下で管理

## OK 例

```jsx
const clickEvent = () => {
  window.alert('hello world');
};
const styleProperty = {
  display: 'flex',
  height: '100vh',
};
return (
  <Box sx={styleProperty}>
    <Text onClick={clickEvent}>click!</Text>
  </Box>
);
```

## NG 例

```jsx
return (
  <Box sx={{ display: 'flex', height: '100vh' }}>
    <Text
      onClick={() => {
        window.alert('hello world');
      }}
    >
      click!
    </Text>
  </Box>
);
```

# 関数定義

- 原則アロー関数で定義
- オブジェクトのメソッドは function 構文で定義
- 関数コンポーネントは React.FC を使わずにアロー関数で定義する

# 可読性ガイドライン

- 抽象的な命名（data, value, item 等）は避ける
  - 一時的な受け皿としてのみ抽象名を使用し、すぐに具体名へ
  - 抽象名をそのまま出力・返却・永続化する場合は NG
  - 例: console.log(data), return item, localStorage.setItem('key', value) など
- マジックナンバーを使用しない
- 省略形（flg, func 等）は禁止
- camelCase で命名
- bool 値の変数名は can/has/is プレフィックスが付いている
- 否定系の名前（isNotValid 等）は NG

## 命名 OK 例

```jsx
const data = await fetch();
setUserList(data);
```

## 命名 NG 例

```jsx
const data = await fetch(); // 以降もdataのまま利用
```

# コメント

- 関数説明は TSDoc 形式で記載

# テストガイドライン

- カバレッジ 80%以上
- テストケースには GIVEN/WHEN/THEN を記載
- 機能・コンポーネント視点でケース作成
  - テストケースが複雑な場合は関数分割で対応
- 1 ロジック 1 テストを遵守
  - 他関数を参照する場合は引数の数・値も担保し、出力や副作用は参照先のテストで担保
- userEvent を使用し、fireEvent は禁止
  - 実際のユーザー操作により近い形でテストを実行する
- i18n テストでは本物のインスタンスを使用
  - モックではなく`@i18n`から実際のインスタンスをインポート
  - テキスト定義の変更に対して堅牢なテストを実現
  - `I18nextProvider`でコンポーネントをラップして使用
- shadcn/ui コンポーネントのモックは避ける
  - 実際のコンポーネントを使用してリグレッションを検知する
  - 必要な場合は最小限のモックにとどめる（Radix のポータル等）
- テーマのモックは避ける
  - 実際のテーマ設定（`@renderer/theme/theme`）を使用する
  - カスタムテーマの定義やモックは避ける
  - テーマの変更に追従できるよう、実際の設定を参照する
- AI がテスト作成を実行する前に、テストケースを提示してユーザに承認をもらうこと。
- テストファイルの表示確認ではハードコードテキストを使用する
  - テスト対象の表示確認は実際に UI に表示される文字列を使用して行う
  - screen.getByText('切り替える')のようにハードコードされた文字列で確認する
  - i18n の翻訳キー（t('locationSelect.switch')）をテストで使用しない

## i18n テスト OK 例

```tsx
import i18n from '@i18n';

describe('多言語対応コンポーネント', () => {
  it('正しく翻訳が表示されること', () => {
    render(
      <I18nextProvider i18n={i18n}>
        <MyComponent />
      </I18nextProvider>
    );
    expect(screen.getByText('実際の翻訳キー')).toBeInTheDocument();
  });
});
```

## i18n テスト NG 例

```tsx
// NG: モックi18nインスタンスを作成
const createTestI18n = (initialLanguage = 'ja') => {
  const i18n = i18next.createInstance();
  i18n.init({
    resources: {
      ja: { translation: { key: 'モック翻訳' } },
    },
  });
  return i18n;
};
```

## shadcn/ui テスト OK 例

```tsx
describe('Button', () => {
  it('variant=default で表示されること', () => {
    render(<Button>送信</Button>);
    expect(screen.getByRole('button', { name: '送信' })).toBeInTheDocument();
  });
});
```

## shadcn/ui テスト NG 例

```tsx
// NG: shadcn/ui をモック
vi.mock('@/components/ui/button', () => ({
  Button: ({ children }: any) => <button>{children}</button>,
}));
```

## テスト OK 例

```jsx
// logMessageのテスト
describe('logMessage関数', () => {
  it('console.logが指定された引数で1回呼ばれること', () => {
    // GIVEN
    const consoleSpy = vi.spyOn(console, 'log');
    // WHEN
    logMessage('test');
    // THEN
    expect(consoleSpy).toHaveBeenCalledWith('test');
    expect(consoleSpy).toHaveBeenCalledTimes(1);
  });
});
// handleClickのテスト
describe('handleClick関数', () => {
  it('handleClick実行時にlogMessage関数が"hello world"で1回呼ばれること', () => {
    // GIVEN
    const messageSpy = vi.spyOn(functions, 'logMessage');
    // WHEN
    handleClick();
    // THEN
    expect(messageSpy).toHaveBeenCalledWith('hello world');
    expect(messageSpy).toHaveBeenCalledTimes(1);
  });
});

// userEventのテスト（推奨）
describe('ボタンクリック処理', () => {
  it('ボタンクリック時にhandleClickが呼ばれること', async () => {
    // GIVEN
    const user = userEvent.setup();
    const mockHandleClick = vi.fn();
    render(<Button onClick={mockHandleClick}>Click Me</Button>);

    // WHEN
    await user.click(screen.getByRole('button'));

    // THEN
    expect(mockHandleClick).toHaveBeenCalledOnce();
  });
});

// ハードコードテキストを使用したテスト（推奨）
describe('LocationSelectコンポーネント', () => {
  it('切り替えボタンが正しく表示されること', () => {
    // GIVEN
    render(<LocationSelect />);

    // THEN - 実際に表示される文字列で確認
    expect(screen.getByText('切り替える')).toBeInTheDocument();
  });
});
```

## テスト NG 例

```jsx
describe('handleClick関数', () => {
  it('handleClick実行時にconsole.logが出力されること', () => {
    const consoleSpy = vi.spyOn(console, 'log');
    handleClick();
    expect(consoleSpy).toHaveBeenCalledWith('hello world');
  });
});

// fireEventの使用（禁止）
describe('ボタンクリック処理', () => {
  it('ボタンクリック時にhandleClickが呼ばれること', () => {
    const mockHandleClick = vi.fn();
    render(<Button onClick={mockHandleClick}>Click Me</Button>);

    // NG: fireEventは使用禁止
    fireEvent.click(screen.getByRole('button'));

    expect(mockHandleClick).toHaveBeenCalledOnce();
  });
});

// 翻訳キーを使用したテスト（禁止）
describe('LocationSelectコンポーネント', () => {
  it('切り替えボタンが表示されること', () => {
    // NG: 翻訳キー使用
    const { t } = useTranslation('home');
    render(<LocationSelect />);
    expect(screen.getByText(t('locationSelect.switch'))).toBeInTheDocument();
  });
});
```

# セキュリティ・堅牢性

- any 型禁止
- interface/type の使い分け（Props/State は interface）
- biome/lint エラー禁止
- コンソール/ターミナルの error/warning 禁止

# 実装上の注意点

- グローバル変数禁止、Zustand のみ許可
- 子が親の useState セッターを直接呼ぶのは制限（副作用や複雑なロジックがある場合はコールバック関数経由）
  - セッター関数を渡して更新して良いケース：
    - 副作用が発生しない
    - 状態の更新ロジックがシンプル
    - 複数の状態や処理が発生する場合はコールバック関数経由
- props でのデータ受け渡しはコンポーネント ↔︎ 関数 1 往復のみ許容（NG: コンポーネント ↔︎ 関数 ↔︎ 関数）
- 3 段階以上の条件分岐ネスト禁止
- 冗長ロジックの回避

# 非同期処理

- Suspense 必須
- データ取得コンポーネントは必ず<Suspense>でラップ
- フォールバック UI はロード状態を明示的に表現
- use()または useActionState で非同期処理を管理
- 未処理の Promise をコンポーネント内で直接待機禁止

## NG 例

```jsx
const data = await fetchData();
```

## OK 例

```jsx
const data = use(fetchData()); // React 19のuse()でラップ
```

# フォームアクション規約

- useActionState の適用
- フォーム状態とサーバーアクションを統合管理
- エラー処理を組み込み

# 楽観的更新

- 不正な楽観的更新の伝播防止
- ネットワークエラー時の状態整合性維持

# 多言語対応ガイドライン

- すべての表示テキストは翻訳キーを使用
- 画像の alt 属性も翻訳キーを使用
- 翻訳キーは機能単位で階層化
- 翻訳ファイルは言語ごとに分割
- useTranslation で namespace を指定（エディタ上で名前が解決されるようになります）

## OK 例

```tsx
const { t } = useTranslation('header'); // namespaceを指定
return <img alt={t('alt.home')} src={homeIcon} />;
```

## NG 例

```tsx
const { t } = useTranslation(); // namespace未指定
return <img alt={t('alt.home')} src={homeIcon} />;
```

## NG 例

```tsx
return <img alt='ホーム' src={homeIcon} />;
```

# テーマ管理ガイドライン

- カラーコードは直接指定せず、テーマから取得
- カラーコードは palette で一元管理
- ダークモード/ライトモードの切り替えはテーマで制御
- カスタムカラーは palette を拡張して定義
- fontSize は sx ではなく variant で指定（元々の指定サイズに一致した variant を使用）

## MUI 利用に関する指針

- MUI コンポーネントは`@mui/material`から直接インポートして使用
- カスタムコンポーネントは`src/renderer/components/ui/`配下に配置
- `sx`プロパティを使用してスタイリングを行う
- テーマカラーは`theme.palette`から取得し、直接カラーコードを指定しない
- コンポーネントの`variant`や`size`プロパティを適切に活用する
- アクセシビリティを考慮した実装を行う

## MUI Typography の指定

- MUI の Typography コンポーネントを使用する
- `variant`プロパティで適切なタイポグラフィスタイルを指定する
- カスタムスタイルは`sx`プロパティで追加する

## OK 例

```tsx
// MUIコンポーネントの適切な使用
<Typography variant="h6" sx={{ color: 'primary.main' }}>
  タイトル
</Typography>

<Button variant="contained" size="large">
  ボタン
</Button>

<Box sx={{ display: 'flex', gap: 2 }}>
  <Card sx={{ p: 2 }}>
    <CardContent>
      <Typography variant="body1">コンテンツ</Typography>
    </CardContent>
  </Card>
</Box>
```

## NG 例

```tsx
// 直接カラーコード指定はNG
<Typography sx={{ color: '#000000' }}>
  テキスト
</Typography>

// 不適切なvariant使用
<Typography variant="h1" sx={{ fontSize: '12px' }}>
  小さなテキスト
</Typography>

// 不要なスタイル指定
<Box sx={{ display: 'flex', flexDirection: 'row' }}>
  <Typography sx={{ color: 'inherit' }}>テキスト</Typography>
</Box>
```

## コンポーネント定義 OK 例

```tsx
const MyComponent = ({ propA, propB }: Props) => {
  return <div>{propA}</div>;
};
```

## コンポーネント定義 NG 例

```tsx
const MyComponent: React.FC<Props> = ({ propA, propB }) => {
  return <div>{propA}</div>;
};
```
